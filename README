NAME
    Plugin::Simple - Simply make your app pluggable

VERSION
    version 0.001

SYNOPSIS
      package YourPlugin;
      use Moose;                           
      with 'Plugin::Simple::Role::Plugin'; 

      has 'input' => (is=>'ro', isa=>'Int');

      sub phase {'foo'}
  
      sub BUILD {
          my ($self)=@_; #receive what you hand over in execute below
          $self->input; #access stuff passed down from core;
          #...
          $self->return ($something); #available in core when plugin is done
      }

      package YourApp;
      use Plugin::Simple;

      #during configuration 
      $ps=Plugin::Simple->new(phases=>['foo', 'bar']); 

      #registers p under its phase & load/use it; $options from Load::Class 
      $ps->register ('YourPlugin',\%options);   

      #later during a phase: execute all plugins in this phase
      @p=$ps->execute (phase=>$phase, core=>$core); 

      foreach my $plugin (@p){
        my $return=$plugins->return_value($plugin);
      }

DESCRIPTION
    WaRNING THiS iS An EaRLY ReLEAsE! NoT QUiTE TeSTED IN ThE WIlD YEt.

    Plugin::Simple provides

    a) a defininition for plugin systems
     No big deal? Yeah, but it's there anyways. See "Tutorial.pod".

    2) suggestions how to roll your own mini-plugin system
     You need only a single sub and three lines of perl. See "Tutorial.pod".
     No moose required.

    3) two minimalistic plugin system
       Plugin::Tiny - only one plugin per phase
       Plugin::Simple - multiple plugins per phase possible
  
       For Plugin::Simple, phase info specified by the plugin. Plugin::Tiny requires 
       the calling instance (core or bundling plugin) to specify the phase. There 
       are some small differences how return values and arguments are handled. If 
       uncertain, try Tiny first. 
  
       Both use Moose and suggest that in your Plugins you do too, but Plugin::Tiny 
       doesn't require you to use Moose.

ATTRIBUTES
  $aref=$ps->phases;
    Getter returns arrayRef with all phase labels.

    Note that order of phases has no impact on when they're called. It's up
    the app which makes use of Plugin::Simple (the core) to call the phases
    when they are needed.

    Plugin::Simple->new (phases=>[qw(a,b,b)]) removes duplicate phases now.

METHODS
  my $href=$ps->registry;
    returns a hashRef with all registered plugins in their respective
    phases: my $registry=$ps->registry;

      #returns first plugin from that phase
      $registry->{$phase}[0];

    You can't use 'registry' in the constructor. Use register instead to get
    plugins into the registry.

  my @plugins=$ps->filter_phases('Test');
    return only those registered plugins whose names fit the filter
    criterion. Currently, only exact matches no regular expressions. Might
    change.

  my @a=$ps->add_phase ('phase1');
    Teach the plugin system a new phase. You can add multiple phases at
    once: my @a=$self->add_phase ('phase1', 'phase2');

  my @registered_plugins=$ps->plugin_list
    List all registered plugins as a list. (It flattens registry to a list.)

  my @plugins=$ps->filter_plugins(/Test/); #no sub!
    return only those registered plugins whose names fit the filter
    criterion.

  my $ret=$ps->return_value($plugin)
    Expects the plugin (label), returns the return value from that plugin.
    If there is no return value it returns undef.

    You better make sure that you executed the plugin, because this method
    doesn't do that for you.

  $ps->register ($plugin, $options)
    Dies (confesses) on failure.

    Should we implement an option for lazy load? Then load would be delayed
    until when we need execute. Not now, but maybe later.

    Returns name of plugin on success.

  my @p = $ps->execute(phase => $phase);
    Makes new plugins for all plugins registered in this phase. Needs phase.
    Optionally accepts arguments for new. Hash elements other than 'phase'
    are passed to new verbatim. Returns list of plugins that were run. Use
    "return_value" to access return value from that plugin.

SEE ALSO
    There are many easy ways to implement plugins in perl. I am trying to
    learn from Dancer and Dist::Zilla, two projects with plugins that I came
    across in the past. Let me know if you think there are other plugin
    systems which I should look at.

    MST's blog

    MooseX::Plaggerize

AUTHOR
    Maurice Mengel <mauricemengel@gmail.com>

COPYRIGHT AND LICENSE
    This software is copyright (c) 2012 by Maurice Mengel.

    This is free software; you can redistribute it and/or modify it under
    the same terms as the Perl 5 programming language system itself.

